.org $600

;.include stdmacros.s

;move.4 #$2233 r1
;move.4 #$11 r2
;_div32 $c4,$c8,$d0,$d4

; m6-m9		%1	(dividend)
; mA-mD		%2	(divisor)
; m1-m4		%3 (quotient)
; 			%4 (remainder)

r0 = $d0		;					quotient
r1 = $d4		; dividend (big)
r2 = $d8		; divisor  (sml)	remainder

md = $dd
me = $de
mf = $df

divisor  = $2
dividend = $FFFFFFef

lda #<dividend
sta r1
lda #>dividend
sta r1+1
lda #>>dividend
sta r1+2
lda #>>>dividend
sta r1+3

lda #<divisor
sta r2
lda #>divisor
sta r2+1
lda #>>divisor
sta r2+2
lda #>>>divisor
sta r2+3

jsr sdiv46
brk

; ***************************************************************************
; Get absolute values of 2 4-byte numbers
; ***************************************************************************

abs4:
	lda r1+3		; Get sign of r2
	eor r2+3		; eor with sign of r3
	sta me			; store in ME
	
	ldx #r1			; set up X to point ro r1
	jsr absneg		; and negate if necessary to make it absval
	
	ldx #r2			; set up X to point to r2
	jsr absneg		; and negate if necessary to make it absval
		
	ldx #0			; clear X and return
	rts

; ***************************************************************************
; Negate a 4-byte value in ZP, pointed to by X
; ***************************************************************************

absneg:
	lda 3,x			; Use X as offset, point to 3rd byte of 4-byte value
	bpl exit		; If it's already +ve, then just return
	
	ldy #4			; set up the counter
	sec				; set the carry at the start

absneg1:
	lda #0			; subtract from 0 to negate
	sbc 0,x			; then store back to the same place
	sta 0,x
	
	inx				; Go to the next byte in the sequence
	dey				; Decrement the counter
	bne absneg1		; and repeat for 4 bytes
	
exit:
	rts



; ***************************************************************************
; Negate r0
; ***************************************************************************
sneg46:
	sec				; Prepare to subtract without borrow

sng1:
	lda #0			; sub 4-byte value at r0
	sbc r0			; and save it back to the same place
	sta r0
	lda #0			; sub 4-byte value at r0+1
	sbc r0+1		; and save it back to the same place
	sta r0+1
	lda #0			; sub 4-byte value at r0+2
	sbc r0+2		; and save it back to the same place
	sta r0+2
	lda #0			; sub 4-byte value at r0+3
	sbc r0+3		; and save it back to the same place
	sta r0+3
	
	asl a			; put sign in carry
	rts


; ***************************************************************************
; 4-byte signed division
; ***************************************************************************

sdiv46:
	lda r1+3		; remainder sign = divisor sign
	sta mf
	
	jsr abs4		; get quotient sign and absolute values
	stx r0			; clear r0
	stx r0+1
	stx r0+2
	stx r0+3
	
	lda r2			; check for divide-by-zero by seeing if
	ora r2+1		; r2 is zero. If so, just flag an error
	ora r2+2
	ora r2+3
	beq error
	
	ldy #32			; We're going to do this 32 times...
	
sdv1:
	asl r1			; 32-bit accumulator-shift-left
	rol r1+1
	rol r1+2
	rol r1+3
	
	rol r0			; 32-bit rotate-left
	rol r0+1
	rol r0+2
	rol r0+3
	
	sec				; Prepare for subtraction
	lda r0			; Subtract divisor from
	sbc r2			; accumulator and store back
	sta r0
	lda r0+1		; And for byte 1
	sbc r2+1
	sta r0+1
	lda r0+2		; And for byte 2
	sbc r2+2
	sta r0+2
	lda r0+3		; And for byte 3
	sbc r2+3
	sta r0+3

	bcs sdv4		; If carry is set, accumulator is positive, skip re-add
	
	clc				; Prepare for addition
	lda r0			; We were negative, so add back in what we just took away
	adc r2
	sta r0
	lda r0+1		; And for byte 1
	adc r2+1
	sta r0+1
	lda r0+2		; And for byte 2
	adc r2+2
	sta r0+2
	lda r0+3		; And for byte 3
	adc r2+3
	sta r0+3
	
	lda #0			; BRA...
	beq sdv5		; Don't do the inc
	
sdv4:
	inc r1			; set results bit

sdv5:
	dey				; repeat ... 32 times
	bne sdv1
	
	bit mf			; check remainder sign
	bpl sdv6		; skip negation if positive
	jsr sneg46		; negate the value
	
sdv6:
	ldx #4			; byte count
	
sdv7:
	lda r0-1,x		; transfer remainder
	sta r2-1,x		; .. to r2
	lda r1-1,x		; transfer quotient
	sta r0-1,x		; .. to r0
	dex
	bne sdv7
	
	bit me			; Check quotient sign
	bpl sdv8		; skip if positive
	jsr sneg46		; else negate
	
sdv8:
	clc				; return ok
	rts
	
error:
	sec				; return error
	rts
	


